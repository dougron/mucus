package main.java.com.dougron.mucus.mu_framework.chord_list;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import org.json.JSONArray;
import org.json.JSONObject;

import main.java.com.dougron.mucus.mu_framework.chord_list.progression_analysis.MucusChordChunkList;
import main.java.com.dougron.mucus.mu_framework.data_types.BarsAndBeats;
import main.java.com.dougron.mucus.mu_framework.ruler.time_signature_list.TimeSignatureGenAndMap;
import main.java.com.dougron.mucus.mu_framework.ruler.time_signature_list.TimeSignatureList;
import main.java.da_utils.chord_progression_analyzer.ChordInKeyObject;
import main.java.da_utils.chord_progression_analyzer.ProgressionAnalyzer;
import main.java.da_utils.chord_progression_analyzer.chord_chunk.ChordChunk;
import main.java.da_utils.chord_progression_analyzer.chord_chunk.ChordChunkList;

/**
 * ChordList is a linear representation of a chord structure similar to 
 * TempoList
 * 
 * ChordLists are generated by a ChordListGenerator
 * 
 * ChordEvents are positioned by BarsAndBeats, quarters and seconds, with BarsAndBeats prioritized when time signature changes
 * 
 * ChordLists are the actual position of the chord, and thus are dependant on the existance of a TimeSignatureGenAndMap
 * 
 * Chord is a reusable chord (like D minor)
 * 
 * @author dougr
 *
 */

public class ChordList
{

	private static final BarsAndBeats DEFAULT_LENGTH_IN_BARS_AND_BEATS = new BarsAndBeats(1, 0.0);
	public static final Chord DEFAULT_CHORD = new Chord();
	
	private List<ChordEvent> chordList = new ArrayList<ChordEvent>();
	private BarsAndBeats lengthInBarsAndBeats = null;
	private ProgressionAnalyzer pa = null;
	private TimeSignatureGenAndMap tsgm;
 
	

	public ChordList()
	{
		setDefaultLengthInBarsAndBeats();
		tsgm = new TimeSignatureGenAndMap();
		chordList.add(new ChordEvent(DEFAULT_CHORD, new BarsAndBeats(0, 0.0), 0.0));
	}
	
	
	
	public ChordList(Chord aChord, TimeSignatureGenAndMap aTsgm)
	{
		tsgm = aTsgm;
		setDefaultLengthInBarsAndBeats();
		chordList.add(new ChordEvent(aChord, new BarsAndBeats(0, 0.0), 0.0));
	}


	
	// this could be a joke or a constructor for testing
	public ChordList(String[] arrayOfChordSymbols, TimeSignatureGenAndMap tsgm)
	{
		int barIndex = 0;
		for (String symbol: arrayOfChordSymbols)
		{
			chordList.add(new ChordEvent(new Chord(symbol), new BarsAndBeats(barIndex, 0.0), tsgm));
			barIndex++;
		}
	}



	private void setDefaultLengthInBarsAndBeats()
	{
		lengthInBarsAndBeats = DEFAULT_LENGTH_IN_BARS_AND_BEATS;
	}
	
	
	
	public void addChord(Chord chord, BarsAndBeats aBarsAndBeats, TimeSignatureGenAndMap aTsgm)
	{
		tsgm = aTsgm;
		if (aBarsAndBeats.isSamePositionAs(0, 0.0))
		{				
			chordList.add(0, new ChordEvent(chord, aBarsAndBeats, aTsgm));
			if (chordList.size() > 1) chordList.remove(1);
		}	
		else
		{
			removeItemFromChordListIfBArsAndBeatsPositionIsTheSame(aBarsAndBeats);
			chordList.add(new ChordEvent(chord, aBarsAndBeats, aTsgm));
			chordList.sort(positionInQuartersComparator);
		}
	}
	
	
	
	public void addChordList(ChordList aChordList, BarsAndBeats aBarsAndBeatsStartPosition, TimeSignatureGenAndMap tsgm)
	{
		removeScopeOfNewChordListFromThisChordList(aBarsAndBeatsStartPosition, aChordList.getLengthInBarsAndBeats(), tsgm);
		for (ChordEvent ce: aChordList.chordList)
		{
			BarsAndBeats bab = new BarsAndBeats
					(
					ce.getPositionInBarsAndBeats().getBarPosition() + aBarsAndBeatsStartPosition.getBarPosition(),
					ce.getPositionInBarsAndBeats().getOffsetInQuarters() + aBarsAndBeatsStartPosition.getOffsetInQuarters()
					);
			BarsAndBeats actualBab = tsgm.getPositionInBarsAndBeats(tsgm.getPositionInQuarters(bab));
			addChord(ce.getChord(), actualBab, tsgm);
		}
		
	}
		
		
	
	private void removeScopeOfNewChordListFromThisChordList(BarsAndBeats aStartBab,
			BarsAndBeats aLengthBab, TimeSignatureGenAndMap tsgm)
	{
		double startInQuarters = tsgm.getPositionInQuarters(aStartBab);
		BarsAndBeats endBab = aStartBab.addBarsAndBeats(aLengthBab, tsgm);
		double endInQuarters = tsgm.getPositionInQuarters(endBab);
		List<ChordEvent> list = new ArrayList<ChordEvent>();
		for (ChordEvent ce: chordList)
		{
			if (ce.getPositionInQuarters() < startInQuarters || ce.getPositionInQuarters() >= endInQuarters)
			{
				list.add(ce);
			}
		}
		chordList = list;
	}



	private void removeItemFromChordListIfBArsAndBeatsPositionIsTheSame(BarsAndBeats aBarsAndBeats)
	{
		ChordEvent found = null;		
		for (ChordEvent ce: chordList)
		{
			if (ce.getPositionInBarsAndBeats().isSamePositionAs(aBarsAndBeats))
			{
				found = ce;
				break;
			}
		}
		if (found != null) chordList.remove(found);
	}



	public static Comparator<ChordEvent> positionInQuartersComparator = new Comparator<ChordEvent>()
		{

			@Override
			public int compare(ChordEvent o1, ChordEvent o2)
			{
				if (o1.getPositionInQuarters() < o2.getPositionInQuarters()) return -1;
				if (o1.getPositionInQuarters() > o2.getPositionInQuarters()) return 1;
				return 0;
			}
			
		};	



	
	public int size()
	{
		return chordList.size();
	}



	public void setLengthInBarsAndBeats(BarsAndBeats aBarsAndBeats)
	{
		lengthInBarsAndBeats = aBarsAndBeats;
//		timeSignatureList = null;
	}



	public BarsAndBeats getLengthInBarsAndBeats()
	{
		return lengthInBarsAndBeats;
	}


	
	public Chord getChord(int aBarPosition, double aOffsetInQuarters)//, TimeSignatureGenAndMap tsgm)
	{
		checkForProgressionAnalyzerAndCreateIfNull();
		if (aBarPosition < getFirstChordBarPosition() 
				|| (aBarPosition == 0 && aOffsetInQuarters < 0.0)
				|| (aBarPosition == lengthInBarsAndBeats.getBarPosition() && aOffsetInQuarters >= lengthInBarsAndBeats.getOffsetInQuarters())
				|| (aBarPosition > lengthInBarsAndBeats.getBarPosition()))
		{
			return null;
		}
		else
		{
			return getChordFromBarAndBeatPosition(aBarPosition, aOffsetInQuarters, tsgm);
		}
		
	}


	
	private Chord getChordFromBarAndBeatPosition(int aBarPosition, double aOffsetInQuarters, TimeSignatureGenAndMap tsgm)
	{
		ChordEvent previousCE = chordList.get(0);
		for (ChordEvent ce: chordList)
		{
			if (ce.getPositionInBarsAndBeats().getPositionComparison(aBarPosition, aOffsetInQuarters, tsgm) == 1)
			{
				return previousCE.getChord();
			}
			previousCE = ce;
		}
		return previousCE.getChord();
	}
	
	
	



	private int getFirstChordBarPosition()
	{
		return chordList.get(0).getPositionInBarsAndBeats().getBarPosition();
	}


	
	public ChordEvent getlastChord()
	{
		return chordList.get(chordList.size() - 1);
	}

	

	public void recalculateFromNewTimeSignatureList(TimeSignatureList tsl)
	{
		List<ChordEvent> list = new ArrayList<ChordEvent>();
		for (ChordEvent ce: chordList)
		{
			ChordEvent newce = new ChordEvent(
					ce.getChord(),
					ce.getPositionInBarsAndBeats(),
					tsl.getBarsAndBeatsPositionInQuarters(ce.getPositionInBarsAndBeats())
							);
			list.add(newce);
			chordList = list;
		}
		
	}



	/*
	 * this is just a string of chord names separated by 
	 * underscore, representing items in the chordList
	 */
	public String chordsToString()
	{
		StringBuilder sb = new StringBuilder();
		for (ChordEvent chord: chordList)
		{
			sb.append(chord.getChord().name() + "_");
		}
		return sb.toString();
	}


	
	public String toString()
	{
		return chordsToString();
	}



//	public ChordList getSubsetChordList(BarsAndBeats aBarsAndBeatsPosition, BarsAndBeats aBarsAndBeatsLength, TimeSignatureGenAndMap tsgm)
//	{
//		ChordList cl = new ChordList();
//		cl.setLengthInBarsAndBeats(aBarsAndBeatsLength);
//		double startInQuarters = tsgm.getPositionInQuarters(aBarsAndBeatsPosition);
//		double endInQuarters = tsgm.getPositionInQuarters(new BarsAndBeats(
//					aBarsAndBeatsPosition.getBarPosition() + aBarsAndBeatsLength.getBarPosition(),
//					aBarsAndBeatsPosition.getOffsetInQuarters() + aBarsAndBeatsLength.getOffsetInQuarters()
//				));
////		TimeSignatureList subsetTSL = tsgm.getSubsetTimeSignature(
////					aBarsAndBeatsPosition.getBarPosition(), 
////					aBarsAndBeatsLength.getBarPosition()
////				);
//		for (ChordEvent ce: chordList)
//		{
//			double quartersPosition = tsgm.getPositionInQuarters(ce.getPositionInBarsAndBeats());
//			if (quartersPosition >= startInQuarters && quartersPosition < endInQuarters)
//			{
////				BarsAndBeats bab = subsetTSL.getQuartersPositionInBarsAndBeats(quartersPosition - startInQuarters); 
//				BarsAndBeats bab = new BarsAndBeats()
//				cl.addChord(ce.getChord(), bab, subsetTSL);
//			}
//		}
//		return cl;
//	}


	
	public List<ChordEvent> getChordEventList()
	{
		return chordList;
	}
	
	
	



	public ChordEvent getNextChordEvent(BarsAndBeats aBarsAndBeats, TimeSignatureGenAndMap tsgm)
	{
		
		for (ChordEvent ce: chordList)
		{
			if (ce.getPositionInBarsAndBeats().getPositionComparison(aBarsAndBeats.getBarPosition(), aBarsAndBeats.getOffsetInQuarters(), tsgm) == 1)
			{
				return ce;
			}
		}
		return getlastChord();
	}



	public double getDistanceInQuartersToNextChordEvent(BarsAndBeats aBarsAndBeats, TimeSignatureGenAndMap tsgm)
	{
//		ChordEvent nextChordEvent = getNextChordEvent(aBarsAndBeats, tsgm);
		double positionInQuarters = tsgm.getPositionInQuarters(aBarsAndBeats);
		double nextChordPositionInQuarters = getPositionOfNextChordEventInQuarters(aBarsAndBeats, tsgm);
		return nextChordPositionInQuarters - positionInQuarters;
	}



	private double getPositionOfNextChordEventInQuarters(BarsAndBeats aBarsAndBeats, TimeSignatureGenAndMap tsgm)
	{
		BarsAndBeats positionInBarsAndBeats = null;
		for (ChordEvent ce: chordList)
		{
			if (ce.getPositionInBarsAndBeats().getPositionComparison(aBarsAndBeats.getBarPosition(), aBarsAndBeats.getOffsetInQuarters(), tsgm) == 1)
			{
				positionInBarsAndBeats = ce.getPositionInBarsAndBeats();
				break;
			}
		}
		if (positionInBarsAndBeats == null) positionInBarsAndBeats = getLengthInBarsAndBeats();
		return tsgm.getPositionInQuarters(positionInBarsAndBeats);
	}



	
	
	
	public String chordAnalysisToString()
	{
		checkForProgressionAnalyzerAndCreateIfNull();
		return pa.analysisToString();
	}
	
	
	
	public JSONObject getProgressionAnalyzerJson ()
	{
		checkForProgressionAnalyzerAndCreateIfNull();
		return progessionAnalysisToJson();
	}


	
	private JSONObject progessionAnalysisToJson ()
	{
		JSONObject json = new JSONObject();
		for (ChordEvent chordEvent: chordList)
		{
			double positionInFloatBars = tsgm.getQuartersPositionInFloatBars(chordEvent.getPositionInQuarters());
			JSONObject ceJson = new JSONObject();
			ceJson.put("name", chordEvent.getChordName());
			ceJson.put("rootIndex", chordEvent.getChord().getRootIndex());
			ceJson.put("chordType", chordEvent.getChord().getNotePattern().name());
			ceJson.put("prevailingKeyIndex", chordEvent.getChord().getAssociatedChordInKeyObject().keyIndex);
			ceJson.put("romanNumeralAnalysis", chordEvent.getChord().getAssociatedChordInKeyObject().degree);
			ceJson.put("romanNumeralAnalysisAddendum", chordEvent.getChord().getAssociatedChordInKeyObject().degreeAddendum);
			ceJson.put("isMajorKey", chordEvent.getChord().getAssociatedChordInKeyObject().isMajorKey);
			ceJson.put("functionString", chordEvent.getChord().getAssociatedChordInKeyObject().degree);
			ceJson.put("chordTones", new JSONArray(chordEvent.getChord().getAssociatedChordInKeyObject().getModChordTones()));
			ceJson.put("scaleTones", new JSONArray(chordEvent.getChord().getAssociatedChordInKeyObject().getModScaleTones()));
			ceJson.put("nonTones", new JSONArray(chordEvent.getChord().getAssociatedChordInKeyObject().getModNonTones()));
			ceJson.put("extendedChordTones", new JSONArray(chordEvent.getChord().getAssociatedChordInKeyObject().getModExtendedChordTones()));
			
			json.put("" + positionInFloatBars, ceJson);
		}
		return json;
	}



	public void refreshChordAnalysis()
	{
		ChordChunkList ccl = new MucusChordChunkList(this);
		pa = new ProgressionAnalyzer(ccl);
//		((MucusChordChunkList)ccl).associateChordChunksWithChords();
		associateChordsAndChordChunks();
	}



	private void associateChordsAndChordChunks()
	{
		ArrayList<ChordInKeyObject> cikoList = pa.analysisChordInKeyObjectList();
		int index = 0;
		for (ChordInKeyObject ciko: cikoList)
		{
			ChordChunk cc = ciko.cc;
			ChordEvent ce = chordList.get(index);
			ce.getChord().setAssociatedChordChunk(cc);
			index++;
		}
	}

	

	private void checkForProgressionAnalyzerAndCreateIfNull()
	{
		if (pa == null) 
		{
			refreshChordAnalysis();
		}	
	}



	public TimeSignatureGenAndMap getTsgm()
	{
		return tsgm;
	}



	


	



	


	

}
